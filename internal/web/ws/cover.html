
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ws: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Lafetz/showdown-trivia-game/internal/web/ws/client.go (4.4%)</option>
				
				<option value="file1">github.com/Lafetz/showdown-trivia-game/internal/web/ws/event.go (0.0%)</option>
				
				<option value="file2">github.com/Lafetz/showdown-trivia-game/internal/web/ws/hub.go (85.7%)</option>
				
				<option value="file3">github.com/Lafetz/showdown-trivia-game/internal/web/ws/rooms.go (48.6%)</option>
				
				<option value="file4">github.com/Lafetz/showdown-trivia-game/internal/web/ws/ws_upgrader.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ws

import (
        "encoding/json"
        "fmt"
        "log"
        "strconv"
        "time"

        "github.com/Lafetz/showdown-trivia-game/internal/core/game"
        render "github.com/Lafetz/showdown-trivia-game/internal/web/Render"
        "github.com/gorilla/websocket"
)

var (
        pongWait     = 10 * time.Second
        pingInterval = (pongWait * 9) / 10
)

type ClientList map[*Client]bool
type Client struct {
        Username   string
        connection *websocket.Conn
        room       *Room
        egress     chan []byte
}

func NewClient(conn *websocket.Conn, room *Room) *Client <span class="cov8" title="1">{
        c := &amp;Client{
                Username:   fmt.Sprintf("user%s", strconv.Itoa(len(room.clients))),
                connection: conn,
                room:       room,
                egress:     make(chan []byte),
        }

        return c
}</span>
func (c *Client) readMessage() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.room.removeClient(c)
        }</span>()
        <span class="cov0" title="0">if err := c.connection.SetReadDeadline(time.Now().Add(pongWait)); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return
        }</span>
        <span class="cov0" title="0">c.connection.SetReadLimit(512)
        c.connection.SetPongHandler(c.pongHandler)
        for </span><span class="cov0" title="0">{
                _, msg, err := c.connection.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway,
                                websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Println("error reading msg: ", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">var req Event
                if err := json.Unmarshal(msg, &amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Println("error reading message", err)
                        break</span>
                }
                //check if valid
                //
                <span class="cov0" title="0">switch req.EventType </span>{
                case StartGame:<span class="cov0" title="0">
                        var players []*game.Player
                        for c := range c.room.clients </span><span class="cov0" title="0">{

                                players = append(players, game.NewPlayer(c.Username))
                        }</span>
                        <span class="cov0" title="0">go c.room.Game.Start(players)</span>
                case SendAnswer:<span class="cov0" title="0">
                        answer := game.NewAnswer(c.Username, req.Payload)
                        c.room.Game.AnswerCh &lt;- answer
                        buff := render.RenderUserAnswer(req.Payload)
                        c.egress &lt;- buff.Bytes()</span>
                default:<span class="cov0" title="0">
                        log.Println("unknown event type:", req.EventType)</span>
                }

        }
}
func (c *Client) writeMessage() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.room.removeClient(c)
        }</span>()
        <span class="cov0" title="0">ticker := time.NewTicker(pingInterval)
        //
        // buf := render.RenderWS()
        // err := c.connection.WriteMessage(websocket.TextMessage, buf.Bytes())
        // println("ping")
        // if err != nil {
        //         return
        // }
        //
        for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.egress:<span class="cov0" title="0">

                        if !ok </span><span class="cov0" title="0">{
                                if err := c.connection.WriteMessage(websocket.CloseMessage, nil); err != nil </span><span class="cov0" title="0">{
                                        log.Println("connection is closed", err)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">if err := c.connection.WriteMessage(websocket.TextMessage, message); err != nil </span><span class="cov0" title="0">{
                                log.Println("failed to send msg", err)
                        }</span>
                        <span class="cov0" title="0">log.Print("message sent")</span>

                case &lt;-ticker.C:<span class="cov0" title="0">

                        if err := c.connection.WriteMessage(websocket.PingMessage, []byte("")); err != nil </span><span class="cov0" title="0">{
                                log.Println("ping failed", err)
                                return
                        }</span>
                }
        }
}
func (c *Client) pongHandler(pongMsg string) error <span class="cov0" title="0">{

        return c.connection.SetReadDeadline(time.Now().Add(pongWait))
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package ws

type Event struct {
        EventType string `json:"type"`
        Payload   string `json:"payload"`
}

func (e *Event) valid() error <span class="cov0" title="0">{
        return nil
}</span>

// type EventHandler func(event Event, c *Client) error

const (
        EventSendMessage = "send_message"
        NewPlayer        = "new_player"
        StartGame        = "start_game"
        SendAnswer       = "send_answer"
)

// type SendMessageEvent struct {
//         Message string `json:"message"`
//         From    string `json:"from"`
// }

// func sendMessage(event Event, c *Client) error {
//         fmt.Println(event.EventType, event.Payload)
//         return nil
// }
</pre>
		
		<pre class="file" id="file2" style="display: none">package ws

import (
        "errors"
        "log"
        "net/http"
        "sync"

        "github.com/Lafetz/showdown-trivia-game/internal/web/entity"
        "github.com/gorilla/websocket"
)

var (
        WebsocketUpgrader = websocket.Upgrader{
                ReadBufferSize:  1024,
                WriteBufferSize: 1024,
                CheckOrigin:     checkOrigin,
        }
)
var (
        ErrRoomNotExist = errors.New("room doens't exist")
)

type Hub struct {
        rooms RoomList
        sync.RWMutex
}

func (h *Hub) getRoom(roomId string) (*Room, error) <span class="cov8" title="1">{
        if room, ok := h.rooms[roomId]; ok </span><span class="cov8" title="1">{
                return room, nil
        }</span> else<span class="cov8" title="1"> {
                return nil, ErrRoomNotExist
        }</span>
}
func (h *Hub) addRoom(room *Room) <span class="cov8" title="1">{
        h.Lock()
        defer h.Unlock()
        h.rooms[room.Id] = room
}</span>
func (h *Hub) ListRooms() []entity.RoomData <span class="cov8" title="1">{
        h.Lock()
        defer h.Unlock()
        var rooms []entity.RoomData
        for _, r := range h.rooms </span><span class="cov8" title="1">{

                rooms = append(rooms, entity.RoomData{
                        Owner:   r.owner,
                        Id:      r.Id,
                        Players: r.getUsers(),
                })
        }</span>
        <span class="cov8" title="1">return rooms</span>
}
func (h *Hub) removeRoom(room *Room) <span class="cov8" title="1">{
        h.Lock()
        defer h.Unlock()
        if _, ok := h.rooms[room.Id]; !ok </span><span class="cov0" title="0">{
                // Room does not exist, handle this case gracefully (e.g., log an error)
                log.Printf("attempted to remove non-existent room: %s", room.Id)
                return
        }</span>
        <span class="cov8" title="1">delete(h.rooms, room.Id)</span>
}

func NewHub() *Hub <span class="cov8" title="1">{
        h := &amp;Hub{
                rooms: make(RoomList),
                // handlers: make(map[string]EventHandler),
        }
        return h
}</span>
func checkOrigin(r *http.Request) bool <span class="cov0" title="0">{
        // origin := r.Header.Get("Origin")
        // switch origin {
        // case "http://localhost:300":
        //         return true
        // default:
        //         return false
        // }
        //        id := uuid.New().String()[:7]

        return true
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package ws

import (
        "sync"

        "github.com/Lafetz/showdown-trivia-game/internal/core/game"
        render "github.com/Lafetz/showdown-trivia-game/internal/web/Render"
)

type RoomList map[string]*Room
type Room struct {
        hub     *Hub
        clients ClientList
        Game    game.Game
        Id      string
        owner   string
        sync.RWMutex
}

func (r *Room) sendMsg(msg []byte) <span class="cov8" title="1">{

        for c := range r.clients </span><span class="cov8" title="1">{

                c.egress &lt;- msg
        }</span>

}

func NewRoom(id string) *Room <span class="cov8" title="1">{
        questions := []game.Question{
                {Question: "What is 2+2?", Options: []string{"A. 2", "B. 4", "C. 43", "D. 1"}, CorrectAnswer: "B"},
                {Question: "What is the capital of France?", Options: []string{"A. London", "B. Berlin", "C. Paris", "D. Rome"}, CorrectAnswer: "C"},
        }
        g := *game.NewGame(questions)
        r := &amp;Room{
                Id:      id,
                clients: make(ClientList),
                owner:   "unkownd_owner",
                Game:    g,
        }
        go func() </span><span class="cov8" title="1">{
                for m := range g.Message </span><span class="cov0" title="0">{
                        switch m.MsgType </span>{
                        case game.MsgQuestion:<span class="cov0" title="0">
                                if payload, ok := m.Payload.(game.Question); ok </span><span class="cov0" title="0">{
                                        buff := render.RenderQuestion(payload, r.Game.CurrentQues, len(g.Questions))
                                        r.sendMsg(buff.Bytes())
                                }</span> else<span class="cov0" title="0"> {
                                        continue</span>
                                }
                        case game.MsgInfo:<span class="cov0" title="0">
                                if payload, ok := m.Payload.(game.Info); ok </span><span class="cov0" title="0">{
                                        buff := render.RenderGameMessage(payload)
                                        r.sendMsg(buff.Bytes())
                                }</span> else<span class="cov0" title="0"> {
                                        continue</span>
                                }
                        case game.MsgGameEnd:<span class="cov0" title="0">
                                if payload, ok := m.Payload.(game.Winners); ok </span><span class="cov0" title="0">{
                                        buff := render.GameEnd(payload)
                                        r.sendMsg(buff.Bytes())
                                }</span> else<span class="cov0" title="0"> {
                                        continue</span>
                                }
                        }

                }
        }()
        <span class="cov8" title="1">return r</span>
}
func (r *Room) addClient(client *Client) <span class="cov8" title="1">{
        r.Lock()
        defer r.Unlock()
        r.clients[client] = true
        buff := render.RenderPlayers(r.Id, r.getUsers())
        r.sendMsg(buff.Bytes())
}</span>
func (r *Room) removeClient(client *Client) <span class="cov0" title="0">{
        r.Lock()
        defer r.Unlock()
        if _, ok := r.clients[client]; ok </span><span class="cov0" title="0">{
                client.connection.Close()
                delete(r.clients, client)
        }</span>
}
func (r *Room) getUsers() []string <span class="cov8" title="1">{
        var users []string
        for c := range r.clients </span><span class="cov8" title="1">{
                users = append(users, c.Username)
        }</span>
        <span class="cov8" title="1">return users</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package ws

import (
        "log"
        "net/http"

        "github.com/google/uuid"
)

func (h *Hub) CreateRoom(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        conn, err := WebsocketUpgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return
        }</span>
        <span class="cov0" title="0">id := uuid.New().String()[:7]
        room := NewRoom(id)
        h.addRoom(room)

        client := NewClient(conn, room)
        //println("wtfc")
        go client.readMessage()
        go client.writeMessage()
        room.addClient(client)</span>

}
func (h *Hub) JoinRoom(w http.ResponseWriter, r *http.Request, roomId string) <span class="cov0" title="0">{

        if roomId == "" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">room, err := h.getRoom(roomId)
        if err != nil </span><span class="cov0" title="0">{
                println(err)
                return
        }</span>
        <span class="cov0" title="0">conn, err := WebsocketUpgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return
        }</span>
        <span class="cov0" title="0">client := NewClient(conn, room)
        go client.readMessage()
        go client.writeMessage()
        room.addClient(client)</span>

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
